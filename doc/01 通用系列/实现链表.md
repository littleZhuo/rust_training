按照原本的计划，智能指针系列要继续写`Rc`和`RefCell`，准备写一个链表的例子来说明。没想到陷入到链表中无法自拔。

Rust的严格所有权导致了实现起来步履维艰，先把阶段性的内容放出来。

```rust
use std::cell::RefCell;
use std::rc::{Rc, Weak};

// 链表中的节点
struct Node {
    value: i32,		// 第一个版本先实现具体类型i32，后续改成泛型T
    next: Option<Rc<RefCell<Node>>>, // 这里按照最“简单”的原则，用最“稳妥”的Option套Rc和RefCell组合来实现。
}

impl Node {
    fn new(value: i32) -> Node {
        Node { value, next: None }
    }

    fn set_next(&mut self, other: &Rc<RefCell<Node>>) {
        self.next = Some(Rc::clone(other));
    }
}

// 双端队列名字，但是第一个版本还是单向的。
struct Deque {
    head: Option<Rc<RefCell<Node>>>,  
    tail: Option<Weak<RefCell<Node>>>, // 暂时没有用起来。
    len: usize,
}

impl Deque {

    fn new() -> Deque {
        Deque {head: None, tail: None, len: 0}
    }

    fn is_empty(&self) -> bool {
        self.len == 0
    }

    fn push_front(&mut self, elem: i32) {
        let new_node = Rc::new(RefCell::new(Node::new(elem)));
        match self.head.take() {
            None => {},
            Some(head) => new_node.borrow_mut().set_next(&head),
        }
        self.head = Some(new_node);
        self.len += 1;
    }

    // 这里就依赖于self.tail，此实现可能还有问题
    // fn push_back(&mut self, elem: i32) {
    //     let new_node = Rc::new(RefCell::new(Node::new(elem)));
    //     if let Some(tail_node) = &self.tail {
    //         tail_node.borrow_mut().set_next(&new_node);
    //         new_node.borrow_mut().set_pre(tail_node);
    //     } else {
    //         self.head = Some(Rc::clone(&new_node));
    //     }
    //     self.tail = Some(Rc::clone(&new_node));
    //     self.len += 1;
    // }

    
	// 最头疼的部分，感觉不用迭代器模式很难打印。实现还有问题
    fn display(&self) {
        let mut node = &self.head;
        while let Some(info) = node {
            println!("{}", info.borrow().value);
            node = info.borrow().next;
        }
    }
}

fn main() {
    let mut d = Deque::new();
    d.push_front(4);
    d.push_front(3);
    d.push_front(2);
    d.push_front(1);

    d.display();
}

```

这里发现大号练废了，所以重新开始，用box先来，简单的搞起。

第一种方法，有一个问题，就是push、print这些方法都必须放在Node上，这不合理。

```rust
#[derive(Debug)]
pub struct ListNode {
    pub val:i32,
    pub next:Option<Box<ListNode>>
}

impl ListNode {
    pub fn new(val:i32) -> Self {
        return ListNode{val:val,next:None}
    }

    pub fn get_last_mut(&mut self) -> &mut Self { // 不希望每次都遍历，更不希望这种方法放在ListNode里
        if let Some(ref mut next_node) = self.next {
            return next_node.get_last_mut();
        } else {
            return self;
        }
    }

    pub fn push_back(&mut self, val:i32) { // 不希望这种方法放在ListNode里
        let new_node = ListNode::new(val);
        self.get_last_mut().next = Some(Box::new(new_node));
    }

    pub fn print_list(&self) { // 不希望这种方法放在ListNode里
        println!("{}", self.val);
        if let Some(ref next_node) = self.next {
            next_node.print_list();
        }
    }
}

fn main() {
    let mut a = ListNode::new(1);
    a.push_back(2);
    a.push_back(3);
    a.push_back(4);
    a.push_back(5);

    a.print_list();
}
```



第二种方法，准备新建List，把那几个方法挪进去

```rust
use std::usize;

#[derive(Debug)]
pub struct ListNode {
    pub val:i32,
    pub next:Option<Box<ListNode>>
}

impl ListNode {
    pub fn new(val:i32) -> Self {
        return ListNode{val:val,next:None}
    }
}

struct List {
    head: ListNode,
    len: usize,
}

impl List {
    fn new() -> Self {
        List{head: ListNode::new(0), len: 0}
    }

    // 先从返回最简单的不可修改的引用开始
    fn get_last_node<'a>(&'a self) -> Option<&'a ListNode> {
        if let Some(ref node1) = self.head.next { 
            // return Some(node1.as_ref()); // 第1个元素
            if let Some(ref node2) = node1.next {
                // return Some(node2.as_ref()); // 第2个元素
                if let Some(ref node3) = node2.next {
                    return Some(node3.as_ref()); // 第3个元素
                } else {
                    return Some(node2.as_ref());
                }
            } else {
                return Some(node1.as_ref());
            }
        } else {
            return None;
        }
    }
}
```

这里做一个实验，一步一步推导出循环条件，但是我发现我对于引用类型（胖指针）理解是不准确的。

胖指针一旦初始化了，还能不能改变值呢？，改变的是什么呢，改变的是指向的内存的内容，还是改变的是指向？

```rust
    let a = 10i32;
    let b = 20i32;

    let mut r = &a;
    println!("{}", a);
    println!("{}", b);
    println!("{}", r);
    r = &b;
    println!("{}", a);
    println!("{}", b);
    println!("{}", r);
```

输出是`10 20 10 10 20 20`，这说明什么，回到rust的等号操作符上来，默认是move，如果实现了copy trait才会拷贝。

> - 常见的**数字类型、bool类型、共享借用指针&**，都是**具有 Copy** 属性的类型。而 **Box、Vec、可写借用指针&mut** 等类型都是**不具备 Copy** 属性的类型。

这里因为是`=&b`是共享借用指针，所以是拷贝。那么这样理解：`&a`操作生成了一个引用类型的临时对象，然后拷贝给了左侧的变量，或者是编译优化直接生成了。

接着继续重构代码

```rust
    fn get_last_node<'a>(&'a self) -> Option<&'a ListNode> {
        // 引入一个可变引用类型的变量，替换以前代码里的node1、node2等等
        let mut cur_node_ref = &self.head;

        if let Some(ref next_node_ref) = cur_node_ref.next { 
            cur_node_ref = next_node_ref;
            if let Some(ref next_node_ref) = cur_node_ref.next {
                cur_node_ref = next_node_ref;
                if let Some(ref next_node_ref) = cur_node_ref.next {
                    return Some(next_node_ref.as_ref()); // 第3个元素
                } else {
                    return Some(cur_node_ref);
                }
            } else {
                return Some(cur_node_ref);
            }
        } else {
            return None; // 这里还有一个异类
        }
    }

// 去除return None特殊处理的版本
    fn get_last_node<'a>(&'a self) -> Option<&'a ListNode> {


        let mut cur_node_ref = &self.head;
        // let mut next_node_ref: &Box<ListNode>;

        if let Some(ref next_node_ref) = cur_node_ref.next { 
            cur_node_ref = next_node_ref;
            if let Some(ref next_node_ref) = cur_node_ref.next {
                cur_node_ref = next_node_ref;
                if let Some(ref next_node_ref) = cur_node_ref.next {
                    return Some(next_node_ref.as_ref()); // 第3个元素
                } else {
                    return Some(cur_node_ref);
                }
            } else {
                return Some(cur_node_ref);
            }
        } else {
            if cur_node_ref as *const ListNode == &self.head as * const ListNode {
                return None;
            } else {
                return Some(cur_node_ref);
            }
        }
    }

// 最终的可行版本，可喜可贺
    fn get_last_node<'a>(&'a self) -> Option<&'a ListNode> {
        let mut cur_node_ref = &self.head;
        
        while let Some(ref next_node_ref) = cur_node_ref.next {
            cur_node_ref = next_node_ref;
        }

        if std::ptr::eq(cur_node_ref, &self.head) {
        // if cur_node_ref as *const ListNode == &self.head as * const ListNode {
            return None;
        } else {
            return Some(cur_node_ref);
        }
    }
```

由此，我的print也可以重构

```rust
    fn print_list(&self) {
        let mut cur_node_ref = &self.head;

        while let Some(ref next_node_ref) = cur_node_ref.next {
            println!("{}", cur_node_ref.val);
            cur_node_ref = next_node_ref;
        }
    }
```


