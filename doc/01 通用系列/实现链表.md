按照原本的计划，智能指针系列要继续写`Rc`和`RefCell`，准备写一个链表的例子来说明。没想到陷入到链表中无法自拔。

Rust的严格所有权导致了实现起来步履维艰，先把阶段性的内容放出来。

```rust
use std::cell::RefCell;
use std::rc::{Rc, Weak};

// 链表中的节点
struct Node {
    value: i32,		// 第一个版本先实现具体类型i32，后续改成泛型T
    next: Option<Rc<RefCell<Node>>>, // 这里按照最“简单”的原则，用最“稳妥”的Option套Rc和RefCell组合来实现。
}

impl Node {
    fn new(value: i32) -> Node {
        Node { value, next: None }
    }

    fn set_next(&mut self, other: &Rc<RefCell<Node>>) {
        self.next = Some(Rc::clone(other));
    }
}

// 双端队列名字，但是第一个版本还是单向的。
struct Deque {
    head: Option<Rc<RefCell<Node>>>,  
    tail: Option<Weak<RefCell<Node>>>, // 暂时没有用起来。
    len: usize,
}

impl Deque {

    fn new() -> Deque {
        Deque {head: None, tail: None, len: 0}
    }

    fn is_empty(&self) -> bool {
        self.len == 0
    }

    fn push_front(&mut self, elem: i32) {
        let new_node = Rc::new(RefCell::new(Node::new(elem)));
        match self.head.take() {
            None => {},
            Some(head) => new_node.borrow_mut().set_next(&new_node),
        }
        self.head = Some(new_node);
        self.len += 1;
    }

    // 这里就依赖于self.tail，此实现可能还有问题
    // fn push_back(&mut self, elem: i32) {
    //     let new_node = Rc::new(RefCell::new(Node::new(elem)));
    //     if let Some(tail_node) = &self.tail {
    //         tail_node.borrow_mut().set_next(&new_node);
    //         new_node.borrow_mut().set_pre(tail_node);
    //     } else {
    //         self.head = Some(Rc::clone(&new_node));
    //     }
    //     self.tail = Some(Rc::clone(&new_node));
    //     self.len += 1;
    // }

    
	// 最头疼的部分，感觉不用迭代器模式很难打印。实现还有问题
    fn display(&self) {
        let mut node = &self.head;
        while let Some(info) = node {
            println!("{}", info.borrow().value);
            node = info.borrow().next;
        }
    }
}

fn main() {
    let mut d = Deque::new();
    d.push_front(4);
    d.push_front(3);
    d.push_front(2);
    d.push_front(1);

    d.display();
}

```

